const hre = require('hardhat');
const { expect } = require('chai');
const fs = require('fs');
const { buildProof, buildSignature } = require('zeronaut/utils/build-proof');

describe('One', function () {
  let zeronaut, level, verifier;
  let circuit;
  let signer;

  let campaignId = ethers.encodeBytes32String('hello');
  let levelId = ethers.encodeBytes32String('one');

  before('get signer', async function () {
    [signer] = await hre.ethers.getSigners();
  });

  before('get circuit', async function () {
    circuit = JSON.parse(
      fs.readFileSync('./circuits/target/circuits.json', 'utf8')
    );
  });

  before('deploy contracts', async function () {
    verifier = await hre.ethers.deployContract('UltraVerifier');
    level = await hre.ethers.deployContract('One', [verifier.target]);
    zeronaut = await hre.ethers.deployContract('Zeronaut', []);
  });

  before('register level', async function () {
    await (await zeronaut.createCampaign(campaignId)).wait();
    await (await zeronaut.setLevel(campaignId, levelId, level.target)).wait();
  });

  describe('submitting a valid proof', function () {
    let proof, publicInputs;

    before('build proof', async function () {
      // Prepare the user's signature
      const { signature, pubKeyX, pubKeyY, hashedMsg } = await buildSignature(
        signer
      );

      // Retrieve or build a proof
      proof = await buildProof(circuit, {
        password: 'zeronaut',
        signature,
        pubKeyX,
        pubKeyY,
        hashedMsg,
      });

      // Construct public inputs
      publicInputs = [...pubKeyX, ...pubKeyY];
    });

    describe('submitting the proof with the signer that generated the proof', function () {
      before('submit the proof', async function () {
        await (await zeronaut.solveLevel(levelId, proof, publicInputs)).wait();
      });

      it('should solve the level', async function () {
        const isSolved = await zeronaut.isLevelSolved(levelId, signer.address);
        expect(isSolved).to.be.true;
      });
    });

    describe('submitting the proof with a different signer', function () {
      it('should revert', async function () {
        const otherSigner = (await hre.ethers.getSigners())[1];
        expect(
          zeronaut.connect(otherSigner).solveLevel(levelId, proof, publicInputs)
        ).to.be.revertedWith('Proof must be generated by player');
      });
    });
  });

  // TODO: Add this test back in
  // describe('submitting an invalid proof', function () {
  //   it('should revert with an invalid proof', async function () {
  //     const proof = await buildProof(circuit, {
  //       password: 'zeronaut',
  //       signature: await signer.signMessage('Hello, Zeronaut!'),
  //     });
  //     const invalidProof =
  //       proof.slice(0, -1) + (parseInt(proof.slice(-1), 16) ^ 1).toString(16);
  //     await expect(level.check(invalidProof, [])).to.be.revertedWithCustomError(
  //       verifier,
  //       'POINT_NOT_ON_CURVE'
  //     );
  //   });
  // });
});
